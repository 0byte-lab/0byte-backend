{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":13660203487410872933,"abi":{"parameters":[{"name":"image_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"p_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"platform_name","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"output_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use dep::sha256;\n\nfn main(\n    // Private input: SHA-256 hash of image_bytes\n    image_hash: [u8; 32],\n\n    // Public inputs\n    p_hash: [u8; 8],       // 64-bit perceptual hash\n    platform_name: [u8; 32], // Fixed-size platform name\n    timestamp: u64,        // Unix timestamp\n    \n    // Public output: hash of all inputs\n    output_hash: pub [u8; 32]\n) {\n    // Combine inputs into a single array for hashing\n    let mut input_bytes: [u8; 72] = [0; 72]; // 32 (image_hash) + 8 (p_hash) + 32 (platform_name) + 8 (timestamp)\n\n    // Copy image_hash\n    for i in 0..32 {\n        input_bytes[i] = image_hash[i];\n    }\n\n    // Copy p_hash\n    for i in 0..8 {\n        input_bytes[32 + i] = p_hash[i];\n    }\n\n    // Copy platform_name\n    for i in 0..32 {\n        input_bytes[40 + i] = platform_name[i];\n    }\n\n    // Convert timestamp (u64) to 8 bytes (big-endian)\n    let mut timestamp_bytes: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        // Extract each byte: (timestamp >> (56 - 8*i)) & 0xFF\n        let shift: u8 = (56 - (i as u64 * 8)) as u8; // Cast to u8\n        timestamp_bytes[i] = ((timestamp >> shift) & 0xFF) as u8;\n    }\n\n    // Copy timestamp_bytes\n    for i in 0..8 {\n        input_bytes[64 + i] = timestamp_bytes[i];\n    }\n\n    // Compute SHA-256 of all inputs\n    let computed_hash: [u8; 32] = sha256::digest(input_bytes);\n\n    // Assert the computed hash matches the public output_hash\n    for i in 0..32 {\n        assert(computed_hash[i] == output_hash[i]);\n    }\n}","path":"/Users/nitin/nolabs/0byte/proof/src/zkp/src/main.nr"},"64":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/Users/nitin/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}